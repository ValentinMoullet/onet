// Package log is an output-library that can print nicely formatted
// messages to the screen.
//
// There are log-level messages that will be printed according to the
// current debug-level set. Furthermore a set of common messages exist
// that are printed according to a chosen format.
//
// The log-level messages are:
//	log.Lvl1("Important information")
//	log.Lvl2("Less important information")
//	log.Lvl3("Eventually flooding information")
//	log.Lvl4("Definitively flooding information")
//	log.Lvl5("I hope you never need this")
// in your program, then according to the debug-level one or more levels of
// output will be shown. To set the debug-level, use
//	log.SetDebugVisible(3)
// which will show all `Lvl1`, `Lvl2`, and `Lvl3`. If you want to turn
// on just one output, you can use
//	log.LLvl2("Less important information")
// By adding a single 'L' to the method, it *always* gets printed.
//
// You can also add a 'f' to the name and use it like fmt.Printf:
//	log.Lvlf1("Level: %d/%d", now, max)
//
// The common messages are:
//	log.Print("Simple output")
//	log.Info("For your information")
//	log.Warn("Only a warning")
//	log.Error("This is an error, but continues")
//	log.Panic("Something really went bad - calls panic")
//	log.Fatal("No way to continue - calls os.Exit")
//
// These messages are printed according to the value of 'Format':
// - Format == FormatLvl - same as log.Lvl
// - Format == FormatPython - with some nice python-style formatting
// - Format == FormatNone - just as plain text
//
// The log-package also takes into account the following environment-variables:
//	DEBUG_LVL // will act like SetDebugVisible
//	DEBUG_TIME // if 'true' it will print the date and time
//	DEBUG_COLOR // if 'false' it will not use colors
// But for this the function ParseEnv() or AddFlags() has to be called.
package log

import (
	"bytes"
	"io"
	"log/syslog"
	"os"
)

// For testing we can change the output-writer
var stdOut io.Writer
var stdErr io.Writer

var bufStdOut bytes.Buffer
var bufStdErr bytes.Buffer

// LoggerInfo is a structure that should be used when creating a logger.
// It contains parameters about how to log (with time, colors, ...) and
// embeds the Logger interface, which should define how the logger should log.
type LoggerInfo struct {
	// These are information-debugging levels that can be turned on or off.
	// Every logging greater than 'debugLvl' will be discarded . So you can
	// Log at different levels and easily turn on or off the amount of logging
	// generated by adjusting the 'debugLvl' variable.
	debugLvl int
	// If 'showTime' is true, it will print the time for each line displayed
	// by the logger.
	showTime bool
	// If 'useColors' is true, logs will be colored (defaults to monochrome
	// output). It also controls padding, since colorful output is higly
	// correlated with humans who like their log lines padded.
	useColors bool
	// When using LoggerInfo, we need to be able to act as a Logger.
	Logger
}

// Logger is the interface that specifies how loggers
// will receive and display messages.
type Logger interface {
	Log(level int, msg string)
	Close()
}

var (
	// concurrent access is protected by debugMut
	loggers        map[int]*LoggerInfo = make(map[int]*LoggerInfo)
	loggersCounter int
)

func init() {
	stdOut = os.Stdout
	stdErr = os.Stderr
}

// OutputToBuf is called for sending all the log.*-outputs to internal buffers
// that can be used for checking what the logger would've written. This is
// mostly used for tests. The buffers are zeroed after this call.
func OutputToBuf() {
	debugMut.Lock()
	defer debugMut.Unlock()
	stdOut = &bufStdOut
	stdErr = &bufStdErr
	bufStdOut.Reset()
	bufStdErr.Reset()
}

// OutputToOs redirects the output of the log.*-outputs again to the os.
func OutputToOs() {
	debugMut.Lock()
	defer debugMut.Unlock()
	stdOut = os.Stdout
	stdErr = os.Stderr
}

// GetStdOut returns all log.*-outputs to StdOut since the last call.
func GetStdOut() string {
	debugMut.Lock()
	defer debugMut.Unlock()
	ret := bufStdOut.String()
	bufStdOut.Reset()
	return ret
}

// GetStdErr returns all log.*-outputs to StdErr since the last call.
func GetStdErr() string {
	debugMut.Lock()
	defer debugMut.Unlock()
	ret := bufStdErr.String()
	bufStdErr.Reset()
	return ret
}

// RegisterLogger will register a callback that will receive a copy of every
// message, fully formatted. It returns the key assigned to the logger (used
// to unregister the logger).
func RegisterLogger(l *LoggerInfo) int {
	debugMut.Lock()
	defer debugMut.Unlock()
	key := loggersCounter
	loggers[key] = l
	loggersCounter += 1
	return key
}

// UnregisterLogger takes the key it was assigned and returned by
// 'RegisterLogger', closes the corresponding Logger and removes it from the
// loggers.
func UnregisterLogger(key int) {
	debugMut.Lock()
	defer debugMut.Unlock()
	if l, ok := loggers[key]; ok {
		l.Close()
		delete(loggers, key)
	}
}

type fileLogger struct {
	file *os.File
}

func (fl *fileLogger) Log(level int, msg string) {
	if _, err := fl.file.WriteString(msg); err != nil {
		panic(err)
	}
}

func (fl *fileLogger) Close() {
	fl.file.Close()
}

// NewFileLogger creates and registers a logger that writes into the file with
// the given path and is using the given LoggerInfo (without the Logger).
// It returns the key assigned to the logger.
func NewFileLogger(path string, lInfo *LoggerInfo) (int, error) {
	// Override file if it already exists.
	file, err := os.Create(path)
	if err != nil {
		return -1, err
	}
	lInfo.Logger = &fileLogger{file: file}
	return RegisterLogger(lInfo), nil
}

type syslogLogger struct {
	writer *syslog.Writer
}

func (sl *syslogLogger) Log(level int, msg string) {
	_, err := sl.writer.Write([]byte(msg))
	if err != nil {
		panic(err)
	}
}

func (sl *syslogLogger) Close() {
	sl.writer.Close()
}

// NewSyslogLogger creates and registers a logger that writes into syslog with
// the given priority and tag, and is using the given LoggerInfo (without the
// Logger).
// It returns the key assigned to the logger.
func NewSyslogLogger(priority syslog.Priority, tag string, lInfo *LoggerInfo) (int, error) {
	writer, err := syslog.New(priority, tag)
	if err != nil {
		return -1, err
	}
	lInfo.Logger = &syslogLogger{writer: writer}
	return RegisterLogger(lInfo), nil
}
